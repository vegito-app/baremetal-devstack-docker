# Gestion litiges

---

# Discussion

Admettons que l'utilisateur re√ßoive une livraison et signe via un `smart contract` la reception ?
Comment un `smart contract` pourrait √™tre utilis√© pour g√©rer post√©rieurement un litige sans pouvoir contraindre les utilisateurs mais en les p√©nalisant en tant qu'utilisateur en attribuant une **r√©putation** √† chaque utilisateur ?
Excellente question, √† la crois√©e du droit, des `smart contracts` et des syst√®mes de **r√©putation** d√©centralis√©s.

Tu veux que la r√©ception soit confirm√©e par un `smart contract`, et qu‚Äôen cas de litige post√©rieur, on ne puisse pas contraindre les utilisateurs (car ce n‚Äôest pas possible dans un syst√®me sans recours l√©gal externe), mais qu‚Äôon puisse les p√©naliser via une **r√©putation** qui influence leur futur usage du syst√®me.

Voici une approche compl√®te, combinant `smart contract`, syst√®me de **r√©putation**, et gestion de **litige communautaire** :

## Sc√©nario de base

- Livraison faite ‚Üí l‚Äôutilisateur confirme via une signature (`tx` sur le `smart contract`).
- Le vendeur re√ßoit le paiement (ou il est d√©bloqu√© d‚Äôun `escrow`).
- Tout va bien, jusqu‚Äô√† ce qu‚Äôun **litige** post√©rieur soit initi√© (marchandise d√©fectueuse, non conforme‚Ä¶).

## Contraintes et objectifs

- ‚ö†Ô∏è Aucune autorit√© centrale ne peut ‚Äúforcer‚Äù une action.
- ‚úÖ Il faut un syst√®me incitatif : rendre les comportements honn√™tes avantageux.
- ‚úÖ La **r√©putation** doit influencer les futurs usages : ex. acc√®s √† certaines fonctionnalit√©s, frais plus √©lev√©s, visibilit√© moindre, etc.

## Architecture possible

### A. `Smart contract` d‚Äôachat avec `escrow` + confirmation

- Lors de l‚Äôachat :
  - Les fonds sont vers√©s sur un contrat d'`escrow`.
  - Un d√©lai X est d√©fini pour contester apr√®s confirmation.
- L‚Äôutilisateur confirme la r√©ception :
  - Soit manuellement (via `tx`),
  - Soit automatiquement apr√®s un timeout si aucune contestation n‚Äôest faite.
- Pass√© ce d√©lai :
  - Les fonds sont d√©bloqu√©s pour le vendeur.
  - Le `smart contract` enregistre l‚Äôaction comme ‚Äútransaction r√©ussie‚Äù.

### B. Syst√®me de **r√©putation** on-chain (ou off-chain associ√© √† une identit√© on-chain)

Chaque utilisateur a un score de **r√©putation** calcul√© sur la base :

| Crit√®re                                    | Pond√©ration |
| ------------------------------------------ | ----------- |
| % de livraisons confirm√©es sans **litige** | + fort      |
| % de **litiges** ouverts                   | - fort      |
| R√¥le dans des **litiges** tranch√©s         | variable    |

‚ö†Ô∏è Le score ne peut pas √™tre modifi√© par coercition, mais chaque action (r√©clamation, **arbitrage**, etc.) impacte directement la **r√©putation**.

### C. M√©canisme de **litige communautaire** / **arbitral**

- Lorsqu‚Äôun utilisateur conteste apr√®s r√©ception :
  - Il d√©pose une preuve hors cha√Æne (photo, document, etc.) sur `IPFS` ou `Arweave`.
  - Il ouvre un **litige** via une `DAO` d‚Äô**arbitrage** ou un syst√®me √† la `Kleros`.
  - Un **jury** al√©atoire d√©centralis√© vote pour trancher.
    - **Jury** = utilisateurs au bon score de **r√©putation**.
    - Vote par engagement-r√©v√©lation (`commit-reveal`) pour √©viter la collusion.
- En fonction du verdict :
  - Aucun remboursement n‚Äôest forc√© (car fonds d√©j√† vers√©s),
  - Mais la **r√©putation** des deux parties est impact√©e :
    - Vendeur jug√© fautif ‚Üí **r√©putation** diminue.
    - Acheteur jug√© incomp√©tent ‚Üí **r√©putation** diminue.

‚ö†Ô∏è Cela pousse les deux parties √† √™tre honn√™tes, car un mauvais score r√©duit leur attractivit√© ou leur acc√®s au syst√®me.

## Int√©gration dans un √©cosyst√®me

Un bon syst√®me de **r√©putation** est utilis√© comme condition d‚Äôacc√®s :

- Par exemple, seuls les vendeurs avec une note > 80 % peuvent vendre certains produits ou acc√©der √† certaines marges.
- Acheteurs avec mauvaise **r√©putation** paient des frais plus √©lev√©s, ou voient leur d√©lai de contestation r√©duit.

## Techniquement : r√©sum√© des composants

| Composant                                             | Description                                            |
| ----------------------------------------------------- | ------------------------------------------------------ |
| `Smart contract` d‚Äô`escrow`                           | G√®re les fonds et les confirmations de livraison       |
| `Smart contract` de **r√©putation**                    | Calcule/stocke la **r√©putation** de chaque utilisateur |
| `DAO` ou **oracle communautaire**                     | Juge les **litiges** en mode d√©centralis√©              |
| Syst√®me `IPFS`/`Arweave`                              | Stockage des preuves hors cha√Æne                       |
| Identit√© unique par wallet (voire preuve de personne) | √âvite les sybils (multi-comptes malveillants)          |

## Exemple minimal (pseudo-code `Solidity` simplifi√©)

```solidity
contract Escrow {
enum Status { Created, Confirmed, Disputed, Released }
mapping(uint => Deal) public deals;

    struct Deal {
        address buyer;
        address seller;
        uint amount;
        Status status;
        uint timestamp;
    }

    function confirmReception(uint dealId) external {
        require(msg.sender == deals[dealId].buyer);
        deals[dealId].status = Status.Confirmed;
        deals[dealId].timestamp = block.timestamp;
    }

    function raiseDispute(uint dealId) external {
        require(msg.sender == deals[dealId].buyer);
        require(deals[dealId].status == Status.Confirmed);
        require(block.timestamp < deals[dealId].timestamp + 3 days);
        deals[dealId].status = Status.Disputed;
        // Emission vers un arbitre off-chain
    }

    function releaseFunds(uint dealId) external {
        require(block.timestamp > deals[dealId].timestamp + 3 days);
        require(deals[dealId].status == Status.Confirmed);
        payable(deals[dealId].seller).transfer(deals[dealId].amount);
        deals[dealId].status = Status.Released;
    }

}
```

## Avantages et limites

### Avantages

- Incitation √† bien se comporter sans coercition.
- Protection post√©rieure possible sans centralisation.
- Syst√®me extensible (blacklists, assurances, etc.)

### Limites

- Pas de retour automatique des fonds si **litige** : n√©cessite un m√©canisme annexe.
- Risques de sybil attack sur les **jur√©s** sans preuve d‚Äôidentit√© ou **r√©putation** solide.
- Complexit√© pour l‚Äôutilisateur final (UX √† soigner avec abstraction des m√©canismes).

## Sch√©ma conceptuel d√©taill√© : Syst√®me de r√©ception & **litiges** avec **r√©putation** (`Stacking` + `Clarity`)

```mermaid
flowchart TD
    A[UTILISATEURS vendeur / acheteur] --> B["Smart contract
    Escrow + Livraison"]
    B --> B1[üîê Paiement bloqu√© √† l'achat : escrow]
    B --> B2[‚úçÔ∏è R√©ception sign√©e par l‚Äôacheteur]
    B --> B3[‚è±Ô∏è D√©lai de litige : 3 jours]
    B --> B4[üßæ Statuts enregistr√©s on-chain]

    B --> C["Smart contract
    R√©putation"]
    C --> C1[Score r√©putation incr./d√©cr.]
    C --> C2[Identit√©: wallet ou SIP-010 token]

    C --> D[‚öñÔ∏è Oracle communautaire / DAO d‚Äôarbitrage]
    D --> D1[Vote d√©centralis√© : type Kleros]
    D --> D2[Stockage des preuves sur IPFS/Arweave]
    D --> D3[Verdict transmis au contrat : impact r√©putation]

    D --> E[üîÑ Syst√®me d'incitation]
    E --> E1[Bonus/malus sur frais]
    E --> E2[Restrictions d‚Äôacc√®s]
    E --> E3[Visibilit√© r√©duite]
```

## D√©tails des composants

### 1. üîê `Smart Contract` ‚ÄúEscrow + Livraison‚Äù (`Clarity`)

- G√®re les achats avec fond bloqu√©.
- Inclut :
  - `register-order`: initier une commande.
  - `confirm-delivery`: r√©ception par l‚Äôacheteur.
  - `raise-dispute`: initier un **litige**.
  - `release-payment`: lib√®re fonds apr√®s d√©lai ou **arbitrage**.

### 2. üìä `Smart Contract` ‚ÄúR√©putation‚Äù

- Mapping principal ‚Üí score (`int`)
- Exemples de fonctions :
  - `add-reputation` / `subtract-reputation`
  - `get-reputation`
  - `blacklist-user?`

### 3. ‚öñÔ∏è `DAO` ou **Oracle d‚Äôarbitrage communautaire**

- Off-chain, mais interfac√© au `smart contract`.
- Les **arbitres** peuvent :
  - Voter apr√®s preuves.
  - Transmettre un `verdict-hash`.
  - Signer le r√©sultat avec des identit√©s on-chain.
- Exemple de techno compl√©mentaire : `Kleros`, ou un module `DAO` custom bas√© sur `Clarity`.

### 4. üßæ Preuves hors cha√Æne

- Les preuves sont :
  - H√©berg√©es sur `IPFS` ou `Arweave`.
  - Associ√©es √† une transaction avec un `CID` (hash) de la preuve.
  - Utilis√©es par les **arbitres** pour juger.

### 5. üéØ M√©canismes d‚Äôincitation

| **R√©putation** | Effets dans le syst√®me                |
| -------------- | ------------------------------------- |
| ‚≠ê Haute       | Frais r√©duits, acc√®s premium          |
| ‚ö†Ô∏è Moyenne     | Neutre                                |
| üö´ Basse       | Acc√®s limit√©, frais √©lev√©s, blacklist |

Les contrats peuvent v√©rifier le score avant autorisation :

```clarity
(define-read-only (can-sell (user principal))
  (>= (get-reputation user) u50))
```

## Exemple `Clarity` simplifi√©

```clarity
(define-map orders ((order-id uint)) ((buyer principal) (seller principal) (amount uint) (status int)))

(define-constant STATUS_CREATED 0)
(define-constant STATUS_CONFIRMED 1)
(define-constant STATUS_DISPUTED 2)
(define-constant STATUS_RELEASED 3)

(define-public (confirm-delivery (order-id uint))
  (let ((order (map-get? orders (tuple (order-id order-id)))))
    (begin
      (asserts! (is-eq tx-sender (get buyer (unwrap! order (err u100)))) (err u101))
      (map-set orders (tuple (order-id order-id))
        (merge order (tuple (status STATUS_CONFIRMED))))
      (ok true))))

(define-public (raise-dispute (order-id uint))
  ;; Ajoute l‚Äôordre en litige et r√©f√©rence vers preuve IPFS
  ...
)

(define-public (adjust-reputation (user principal) (score-change int))
  ;; appel√© par arbitre ou DAO
  ...
)
```

## Extensions possibles

- üîê Int√©gration `SIP-009` (`NFTs`) ou `SIP-010` (`fungible tokens`) pour staking **r√©putation**.
- ‚õìÔ∏è `verifiable credentials` ou `soulbound tokens` pour lier **r√©putation** √† l‚Äôidentit√©.
- ü§ñ Auto-**arbitrage** par IA d√©ploy√©e hors cha√Æne pour pr√©-filtrage.

## R√©sum√©

| √âl√©ment                                 | Nature                 | R√¥le                                      |
| --------------------------------------- | ---------------------- | ----------------------------------------- |
| `Smart contract` `Clarity` ‚ÄúEscrow‚Äù     | On-chain               | G√®re paiements et statuts de livraison    |
| `Smart contract` `Clarity` ‚ÄúR√©putation‚Äù | On-chain               | Stocke et met √† jour la **r√©putation**    |
| `DAO` d‚Äô**arbitrage**                   | Off-chain ou sidechain | Juge les **litiges** et √©met les verdicts |
| Preuves `IPFS`/`Arweave`                | Off-chain              | Fournissent les √©l√©ments de **litige**    |
| Incitations/acc√®s                       | Off-chain ou on-chain  | R√®glent l‚Äôacc√®s selon la **r√©putation**   |

## D√©monstration compl√®te : contrat `Clarity` `Escrow` + **R√©putation**

### Objectif du contrat

1. L‚Äôacheteur d√©pose des fonds dans un `escrow`.
2. Le vendeur livre un produit/service.
3. L‚Äôacheteur peut confirmer la r√©ception ou initier un **litige**.
4. Le contrat met √† jour une **r√©putation** on-chain pour les deux parties.
5. Un **arbitre** peut trancher un **litige** (simplifi√© ici).

### Code `Clarity`

```clarity
(define-data-var buyer principal tx-sender)
(define-data-var seller principal 'ST000000000000000000002AMW42H) ;; √† d√©finir dynamiquement dans une vraie app
(define-data-var escrow-amount uint u0)
(define-data-var funds-locked bool false)
(define-data-var delivered bool false)
(define-data-var confirmed bool false)
(define-data-var dispute bool false)
(define-data-var reputation-map (map principal uint))

;; Buyer initie l'escrow
(define-public (init-escrow (seller-addr principal))
  (begin
    (asserts! (not (var-get funds-locked)) (err u100)) ;; d√©j√† initi√©
    (var-set buyer tx-sender)
    (var-set seller seller-addr)
    (var-set escrow-amount (stx-get-transfer-amount))
    (var-set funds-locked true)
    (ok true)
  )
)

;; Buyer transf√®re les fonds
(define-public (deposit)
  (let ((buyer-addr (var-get buyer)))
    (begin
      (asserts! (is-eq tx-sender buyer-addr) (err u101))
      (asserts! (not (var-get confirmed)) (err u102))
      (stx-transfer? (var-get escrow-amount) tx-sender (as-contract tx-sender))
    )
  )
)

;; Seller marque la livraison
(define-public (mark-delivered)
  (begin
    (asserts! (is-eq tx-sender (var-get seller)) (err u103))
    (var-set delivered true)
    (ok true)
  )
)

;; Buyer confirme la r√©ception
(define-public (confirm-receipt)
  (begin
    (asserts! (is-eq tx-sender (var-get buyer)) (err u104))
    (asserts! (var-get delivered) (err u105))
    (stx-transfer? (var-get escrow-amount) (as-contract tx-sender) (var-get seller))
    (var-set confirmed true)
    (update-reputation (var-get seller) u1)
    (ok true)
  )
)

;; Buyer initie un litige
(define-public (init-dispute)
  (begin
    (asserts! (is-eq tx-sender (var-get buyer)) (err u106))
    (var-set dispute true)
    (ok true)
  )
)

;; Arbitre tranche en faveur du vendeur
(define-public (resolve-dispute (winner principal))
  (let (
        (buyer-addr (var-get buyer))
        (seller-addr (var-get seller))
       )
    (begin
      ;; Simulons que tx-sender est un arbitre autoris√©
      (asserts! (is-eq tx-sender 'ST000000000000000000002ARBITR) (err u107))
      (asserts! (var-get dispute) (err u108))

      (if (is-eq winner seller-addr)
        (begin
          (stx-transfer? (var-get escrow-amount) (as-contract tx-sender) seller-addr)
          (update-reputation seller-addr u1)
          (update-reputation buyer-addr u-1)
        )
        (begin
          (stx-transfer? (var-get escrow-amount) (as-contract tx-sender) buyer-addr)
          (update-reputation buyer-addr u1)
          (update-reputation seller-addr u-1)
        )
      )
    )
  )
)

;; Mise √† jour de la r√©putation
(define-private (update-reputation (user principal) (delta int))
  (let ((current (default-to u0 (map-get? reputation-map user))))
    (map-set reputation-map user (+ current delta))
  )
)

;; Lecture de la r√©putation
(define-read-only (get-reputation (user principal))
  (default-to u0 (map-get? reputation-map user))
)
```

## R√©sum√© des acteurs

- `buyer`: l‚Äôinitiateur, qui d√©pose les fonds.
- `seller`: le vendeur qui livre.
- `arbitre`: adresse fixe dans ce contrat, pourrait √™tre `DAO` ou groupe de votants dans une version d√©centralis√©e.

## Possibles am√©liorations

- **Arbitrage** via **jury** al√©atoire on-chain (`DAO`, `SIP-009`).
- D√©lais de livraison via bloc-height.
- **R√©putation** d√©clinante dans le temps ou pond√©r√©e par le montant.

---

## Signature `Clarity` : frontend ou backend ?

### 1. Frontend (obligatoire pour la signature)

üëâ La signature d‚Äôune transaction `Clarity` DOIT obligatoirement se faire c√¥t√© utilisateur, via son wallet non-custodial (`Xverse`, `Hiro`, etc.), car :

- Seul le utilisateur d√©tient la cl√© priv√©e.
- Le backend n‚Äôa pas le droit (ni les moyens) de signer √† sa place, sauf dans un syst√®me custodial, ce qui n‚Äôest pas ton cas.

Donc OUI, l‚Äôinteraction avec la blockchain passe toujours par le frontend au moment de la signature.

### 2. Backend (logique m√©tier et monitoring, PAS de signature)

Le backend :

- Peut pr√©parer une transaction (payload, param√®tres).
- Peut la transmettre au frontend via `Firebase`/`REST`.
- Peut √©couter la confirmation via un `indexer` ou `WebSocket`.
- Peut d√©clencher automatiquement certaines actions (timeouts, **arbitrage**, **r√©putation**) via un wallet administratif (non utilisateur).

Exemples :

- Si un **litige** n‚Äôest pas r√©solu dans les 48h, un backend worker appelle `resolve-dispute` avec la cl√© d‚Äôun **arbitre** (ce wallet-l√† peut √™tre g√©r√© par `Vault`).
- Le backend n‚Äôintervient jamais pour signer √† la place d‚Äôun utilisateur.

## UX sans friction : meilleures pratiques

| √âtape                           | D√©tail                                                                |
| ------------------------------- | --------------------------------------------------------------------- |
| Pr√©parer la transaction c√¥t√© Go | G√©n√©rer les bons param√®tres (`ClarityValue`), identifiant de contrat. |
| Transmettre au frontend         | Via `Firestore` ou `REST API`.                                        |
| Signer dans le wallet           | `Flutter SDK` ou `WebView` vers `Hiro Connect` ou `Xverse SDK`.       |
| √âviter les temps morts          | Animer l‚Äôattente, afficher √©tat de broadcast, et confirmation.        |
| Ne pas bloquer l‚ÄôUI             | Utiliser async + retours `Firestore` pour mise √† jour en temps r√©el.  |

## Illustration du flow

Utilisateur clique "Initier `Escrow`"  
‚Üì  
`Flutter` appelle backend (pr√©paration)  
‚Üì  
Backend retourne les param√®tres (adresse, fonction, args)  
‚Üì  
`Flutter` appelle `wallet.signAndBroadcast(...)`  
‚Üì  
Transaction `Clarity` est diffus√©e  
‚Üì  
`Stacking SDK` ou backend √©coute la blockchain (event confirmation)  
‚Üì  
`Firestore` est mis √† jour (status = initiated, txid = ...)  
‚Üì  
UI refl√®te l‚Äô√©tat automatiquement

## R√©sum√©

- ‚úÖ Signature = frontend uniquement, car la seed reste priv√©e
- üîÅ Backend = monitoring, timeout, arbitrage (avec wallet d√©di√©)
- üéØ UX fluide = pr√©paration backend + SDK Flutter natif pour signer

Souhaites-tu que je t‚Äôaide √† mettre en place le bridge Flutter ‚Üî Wallet STX (par ex. Hiro Connect ou Xverse Wallet SDK pour Flutter) ?

---

## D√©roulement typique : timeline (~5 minutes)

### Hypoth√®ses nominales :

- Utilisateur connect√© (`Firebase` + wallet `STX` d√©j√† appair√©)
- Paiement sign√© imm√©diatement
- Livraison valid√©e rapidement
- **R√©putation** mise √† jour c√¥t√© `Clarity` ou `Firestore`

### Diagramme Mermaid timeline

```mermaid
timeline
title D√©roulement nominal `Escrow` + **R√©putation** (en minutes)

    section Init Escrow
      Ouvrir `EscrowPage` : 0
      Pr√©paration backend + affichage UI : 0.1
      Signature par wallet : 0.3
      Diffusion sur la blockchain : 0.5
      Confirmation Clarity (~1 block) : 1.0

    section Livraison
      Exp√©dition hors-app : 1.5
      Bouton "Confirmer la r√©ception" : 3.0
      Signature confirmation + broadcast : 3.1
      Confirmation Clarity : 3.6

    section R√©putation
      R√©putation actualis√©e dans Firestore ou Clarity : 3.7
      UI mise √† jour automatiquement : 4.0
```

## Explications compl√©mentaires :

- 0.1 min : temps backend pour g√©n√©rer le payload et renvoyer vers frontend.
- 0.5 min : inclut signature + envoi dans mempool + confirmation (Stacks a des blocs toutes ~30s √† 1 min).
- 1.5 √† 3 min : temps de livraison r√©el, arbitraire ici (ex. livraison d‚Äôun fichier, d‚Äôun service en ligne, etc.)
- 3.6 min : la confirmation de confirm-delivery peut aussi prendre ~1 bloc.

### R√©sum√© textuel

| √âtape                             | Temps approximatif |
| --------------------------------- | ------------------ |
| Init `Escrow` (UI √† confirmation) | 1 min              |
| Livraison r√©elle                  | ~1.5 ‚Äì 2 min       |
| Confirmation + **r√©putation**     | ~1 min             |
| **Total nominal**                 | **~5 min**         |
